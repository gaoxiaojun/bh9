#ifndef BAR_FACTORY_ITEM_H
#define BAR_FACTORY_ITEM_H

#include "clock.h"
#include "event.h"

namespace h9 {

class BarFactory;

class BarFactoryItem {
public:
  BarFactoryItem(InstrumentId iid, Bar::Type barType, long barSize,
                 Bar::Input barInput = Bar::Input::Trade, ProviderId pid = -1)
      : m_pid(pid), m_iid(iid), m_type(barType), m_input(barInput),
        m_size(barSize), m_bar(nullptr) {}

  virtual ~BarFactoryItem();

public:
  ProviderId pid() const { return m_pid; }
  InstrumentId instrument_id() const { return m_iid; }

  const BarFactory *factory() const { return m_factory; }
  void set_factory(const BarFactory *f) const { m_factory = f; }

protected:
  void process(const Event::Pointer& e) {
    EMarketData *tick = static_cast<EMarketData *>(e.get());
    if (m_pid != -1 && tick->pid() != m_pid)
      return;

    if (!in_session(tick->time()))
      return;

    on_data(e);
  }

  virtual void on_data(Event::Pointer e) {
    EMarketData *tick = static_cast<EMarketData *>(e.get());
    if (m_bar == nullptr) {
      doubel price = tick->price();
      m_bar = new Bar(get_open_time(e), get_event_time(e, Clock::kLocal), tick->iid(),
                      m_type, m_size, price, price, price, price, tick->size());
      m_bar->setStatus(Bar::Status::kOpen);
      m_factory.framework().event_server().on_event(m_bar);
    } else {
      if (tick->price() > m_bar->high())
        m_bar->set_high(tick->price());

      if (tick->price() < m_bar->low())
        m_bar->set_low(tick->price());

      m_bar->set_close(tick->price());
      m_bar->set_volume(m_bar->volume() + tick->size());
      m_bar->set_time(get_event_time(e, Clock::Type::kLocal)); // Q: this update EBar time, not bar
    }
  }

  virtual void on_reminder(ptime time) {}
  virtual ptime get_bar_open_time(Event::Pointer e) { return e->time(); }
  virtual ptime get_bar_close_time(Event::Pointer e) { return e->time(); }
  virtual ptime get_event_time(Event::Pointer e, Clock::Type type)
  {
      ETick *tick = static_cast<ETick*>(e.get());
      return type == Clock::Type::kLocal ? tick->time() : tick->exchange_time();
  }

  bool add_reminder(ptime time, Clock::Type type)
  {
      m_factory->add_reminder(*this, ptime, type);
  }

  void emit_bar()
  {
      m_bar->set_status(Bar::Status::kClose);
      m_factory->framework()->event_server()->on_event(m_bar);
      m_bar = nullptr;
  }

  friend bool operator==(const BarFactoryItem &lhs, const BarFactoryItem &rhs) {
    return lhs.m_type == rhs.m_type && lhs.m_size == rhs.m_size &&
           lhs.m_input == rhs.m_input && lhs.m_pid == rhs.m_pid;
  }

private:
  mutable BarFactory *m_factory;
  ProviderId m_pid;
  InstrumentId m_iid;
  Bar::Type m_type;
  Bar::Input m_input;
  long m_size;
  bool m_session_enable;
  Bar *m_bar;
};

class TimeBarFactoryItem : public BarFactoryItem {
private:
  Clock::Type m_type;

public:
  TimeBarFactoryItem(InstrumentId iid, long barSize, Bar::Input input,
                     Clock::Type type, Provider pid = -1)
      : BarFactoryItem(iid, Bar::Type::Time, barSize, input, pid) {}

protected:
  void on_data(Event::Pointer e) override {
    bool barOpen = m_bar == nullptr;
    BarFactoryItem::on_data(e);
    if (barOpne) {
      add_reminder(get_bar_close_time(e), m_type);
    }
  }
};

class TickBarFactoryItem : public BarFactoryItem {};

class RangeBarFactoryItem : public BarFactoryItem {};

class VolumeBarFactoryItem : public BarFactoryItem {};

class SessionBarFactoryItem : public BarFactoryItem {};

} // namespace h9

#endif // BAR_FACTORY_ITEM_H
